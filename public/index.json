[{"categories":["Writeups"],"content":"Writeup for The Cryptography challenge.","date":"2023-07-20","objectID":"/squ1rrel-ctf-2024/","tags":["crypto"],"title":"SQU1RREL CTF 2024","uri":"/squ1rrel-ctf-2024/"},{"categories":["Writeups"],"content":"Write-up for SQU1RREL CTF 2024 Lazy RSA Challenge Information\rPoint: 110 Description: ‚ÄúGenerating primes is too hard, but i did find a couple posted online!‚Äù n: 23690620655271165329693230765997410033604713853187305472268813793031152348107488119317901392104240429826482611449247251262846508667797483465355228800439339041030982259847598574606272955688345490638311164838117491821117626835340577511562130640807587611523935604871183668968359720411023759980144229161581597397061850707647104033348795132205561234674677139395868595692235525931999596382758921793937149945229459379437008216713404350896206374483356969246476531491049930769999387038678280465689487577291475554699094024761030833540509263174840007922218340417888061099317752496279552046029470370474619439450870110783844218281 e: 65537 ct: 11420169733597912638453974310976296342840438772934899653944946284527921765463891354182152294616337665313108085636067061251485792996493148094827999964385583364992542843630846911864602981658349693548380259629884212903554470004231160866680745154066318419977485221228944716844036265911222656710479650139274719426252576406561307088938784324291655853920727176132853663822020880574204790442647169649094846806057218165102873847070323190392619997632103724159815363319643022552432448214770378596825200154298562513279104608157870845848578603703757405758227316242247843290673221718467366000253484278487854736033323783510299081405 N factor ƒë∆∞·ª£c n√™n ta d·ªÖ d√†ng c√≥ ƒë∆∞·ª£c FLAG. Flag: squ1rrel{laziness_will_be_the_answer_eventually} RSA RSA RSA Challenge Information\re: 3 n1: 96137714481560340073780038250015316564930752333880363375193088083653975552334517899735106334409092229494004991796910602440032630762575914714152238916128674595912438177270978040111855327624812652948702562503276973409716595778936978757384935820012322432156169815110042972411989274515686945691887468406312791931 ct1: 45640508926729498938915879450220374487095109122207451961200230820161694723491945276893630019713859109920025191680053056485030809079137883906737197875968862878423820820515399840094772412319820062860149582361429346029277273870654355752499436360499181221418835401103925420623212341317366954144592892392013649421 n2: 90990790933807553440094447797505116528289571569256574363585309090304380702927241663491819956599368816997683603352289726407304960362149545383683196526764288524742203975596414405902155486632888712453606841629050125783639571606440840246928825545860143096340538904060826483178577619093666337611264852255012241011 ct2: 58149644956871439128498229750735120049939213159976216414725780828349070974351356297226894029560865402164610877553706310307735037479690463594397903663323983980128060190648604447657636452565715178438939334318494616246072096228912870579093620604596752844583453865894005036516299903524382604570097012992290786402 n3: 86223965871064436340735834556059627182534224217231808576284808010466364412704836149817574186647031512768701943310184993378236691990480428328117673064942878770269493388776005967773324771885109757090215809598845563135795831857972778498394289917587876390109949975194987996902591291672194435711308385660176310561 ct3: 16168828246411344105159374934034075195568461748685081608380235707338908077276221477034184557590734407998991183114724523494790646697027318500705309235429037934125253625837179003478944984233647083364969403257234704649027075136139224424896295334075272153594459752240304700899700185954651799042218888117178057955 V·ªõi b√†i n√†y ta nghƒ© ƒë·∫øn ngay CRT. Solution: from Crypto.Util.number import long_to_bytes e = 3 n1 = 96137714481560340073780038250015316564930752333880363375193088083653975552334517899735106334409092229494004991796910602440032630762575914714152238916128674595912438177270978040111855327624812652948702562503276973409716595778936978757384935820012322432156169815110042972411989274515686945691887468406312791931 ct1 = 4564050892672949893891587945022037448709510912220745196120023082016169472349194527689363001971385910992002519168005305648503080907913788390673719787596886287","date":"2023-07-20","objectID":"/squ1rrel-ctf-2024/:0:0","tags":["crypto"],"title":"SQU1RREL CTF 2024","uri":"/squ1rrel-ctf-2024/"},{"categories":["Writeups"],"content":"squ1rrel treasury Challenge Information\rnc treasury.squ1rrel-ctf-codelab.kctf.cloud 1337 chall.py ƒê·ªçc k·ªπ source code ta nh·∫≠n ra c√°ch m√£ h√≥a Key c·ªßa n√≥ ch√≠nh l√† CBC, th·∫ø m√† √¥ng author c·ª© th√≠ch vi·∫øt d√†i d√≤ng th√¥iii ü§°. V√† ta s·∫Ω s·ª≠ d·ª•ng Flip CBC ƒë·ªÉ l·∫•y ƒë∆∞·ª£c FLAG. def getKey(self): save = f\"{self.__name}:{self.__balance}\".encode() blocks = blockify(save, AES.block_size) pblocks = pad(blocks, b'\\x00', AES.block_size) cipher = AES.new(KEY, AES.MODE_ECB) ct = [] for i, b in enumerate(pblocks): if i == 0: tmp = strxor(b, self.__iv) ct.append(cipher.encrypt(tmp)) else: tmp = strxor(strxor(ct[i-1], pblocks[i-1]), b) ct.append(cipher.encrypt(tmp)) ct_str = f\"{self.__iv.hex()}:{(b''.join(ct)).hex()}\" return ct_str def load(key: str): key_split = key.split(':') iv = bytes.fromhex(key_split[0]) ct = bytes.fromhex(key_split[1]) cipher = AES.new(KEY, AES.MODE_ECB) pt = blockify(cipher.decrypt(ct), AES.block_size) ct = blockify(ct, AES.block_size) for i, p in enumerate(pt): if i == 0: pt[i] = strxor(p, iv) else: pt[i] = strxor(strxor(ct[i-1], pt[i-1]), p) pt = b''.join(pt) pt_split = pt.split(b':') try: name = pt_split[0].decode() except Exception: name = \"ERROR\" balance = int(pt_split[1].strip(b'\\x00').decode()) return Account(iv, name, balance) Ban ƒë·∫ßu balance = 0 v√† n√≥ s·∫Ω ƒë∆∞·ª£c g·ªôp v·ªõi name ƒë·ªÉ m√£ h√≥a v√† tr·∫£ v·ªÅ cho ta ciphertext, iv. V√≠ d·ª• t√™n ta g·ª≠i v√†o l√†: name = \"quanda\", th√¨ s·∫Ω tr·∫£ v·ªÅ encrypt_CBC(\"quanda:0\"). Ta c√≥ max(FLAG_COST) = 10**14-1 n√™n target c·ªßa ta l√† balance = max(FLAG_COST). FLip CBC C√°ch ho·∫°t ƒë·ªông c·ªßa CBC: M√†u xanh c·ªßa iv cho th·∫•y Plaintext thay ƒë·ªïi v·ªõi bytes t∆∞∆°ng ·ª©ng v·ªõi iv. C√≤n m√†u ƒë·ªè c·ªßa ciphertext c·ªßa block th·ª© 2 n√≥ c√≥ ·∫£nh h∆∞·ªüng l√†m thay ƒë·ªïi to√†n b·ªô plaintext. Ta c√≥: $P_1 = Dec_k(C1) \\bigoplus IV$ Set: $target = Dec_k(C1) \\bigoplus IV‚Äô$ $\\to IV‚Äô = IV \\bigoplus P_1 \\bigoplus target$ M√¨nh s·∫Ω ch·ªçn name = \"a\"*14 khi ƒë√≥ ta s·∫Ω c√≥ m·ªôt block l√†: p = \"aaaaaaaaaaaaaa:0\" Target m√¨nh ch·ªçn l√† t = \"a:99999999999999\". V√¨ kh√¥ng s·ª≠ d·ª•ng qu√° nhi·ªÅu payload n√™n m√¨nh s·∫Ω nh·∫≠p tr·ª±c ti·∫øp ƒë·∫øn server lu√¥n n√™n s·∫Ω kh√¥ng c√≥ script n√†o c·∫£ ü§£. ƒê√¢y l√† ƒëo·∫°n t√≠nh to√°n new_iv. iv = bytes.fromhex('4a048459ad3ebc3b68c4c61d091a4b9b') target = b'a:'+b'9'*14 c = bytes.fromhex(\"4ccffa2f796ce4381f37ba63a74d8a99\") new_iv = xor(xor(target, b'a'*14+b':0'), iv).hex() print(new_iv) Flag: squ1rrel{7H3_4C0rN_3NCrYP710N_5CH3M3_15_14CK1N6} ","date":"2023-07-20","objectID":"/squ1rrel-ctf-2024/:1:0","tags":["crypto"],"title":"SQU1RREL CTF 2024","uri":"/squ1rrel-ctf-2024/"},{"categories":["Writeups"],"content":"Squ1rrel Lottery Challenge Information\rsqu1rrel-lottery.py nc 34.132.166.199 11112 import random # user version def input_lines(): lines = [] print(\"Welcome to the squ1rrel lottery! 9 winning numbers will be selected, and if any of your tickets share 3 numbers with the winning ticket you'll win! Win 1000 times in a row to win a flag\") for i in range(1, 41): while True: line = input(f\"Ticket {i}: \").strip() numbers = line.split() if len(numbers) != 9: print(\"Please enter 9 numbers\") continue try: numbers = [int(num) for num in numbers] if not all(1 \u003c= num \u003c= 60 for num in numbers): print(\"Numbers must be between 1 and 60\") continue lines.append(set(numbers)) break except ValueError: print(\"Please enter only integers.\") return lines user_tickets = input_lines() wincount = 0 for j in range(1000): winning_ticket = random.sample(range(1, 61), 9) win = False for i in user_tickets: if len(i.intersection(set(winning_ticket))) \u003e= 3: print(f'Win {j}!') win = True wincount += 1 break if not win: print(\"99 percent of gamblers quit just before they hit it big\") break if wincount == 1000: print(\"squ1rrelctf{test_flag}\") V·ªõi challenge n√†y ta s·∫Ω gen ra 40 ticket. N·∫øu nh∆∞ c√≥ m·ªôt trong 40 ticket ƒë√≥ c√≥ 3 s·ªë trong winning_ticket th√¨ s·∫Ω th·∫Øng. V√† ta ph·∫£i d√πng 40 ticket ƒë√≥ ƒë·ªÉ th·∫Øng 1000 th√¨ ta s·∫Ω FLAG. M·ªói ticket bao g·ªìm 9 s·ªë kh√°c nhau t·ª´ 1 ƒë·∫øn 60. ","date":"2023-07-20","objectID":"/squ1rrel-ctf-2024/:2:0","tags":["crypto"],"title":"SQU1RREL CTF 2024","uri":"/squ1rrel-ctf-2024/"},{"categories":["Writeups"],"content":"Writeup for the Cryptography challenges.","date":"2023-07-03","objectID":"/uiu-crypto/","tags":["crypto","UIU CTF","english"],"title":"UIU CTF 2023 - Cryptography Writeups","uri":"/uiu-crypto/"},{"categories":["Writeups"],"content":"Writeup for the Cryptography challenges. ","date":"2023-07-03","objectID":"/uiu-crypto/:0:0","tags":["crypto","UIU CTF","english"],"title":"UIU CTF 2023 - Cryptography Writeups","uri":"/uiu-crypto/"},{"categories":["Writeups"],"content":"Overview UIU CTF ended just a few hours back. This year‚Äôs Crypto was easier than last year‚Äôs. But it was very fun to solve, especially group projection and morphing time. I managed to solve 5/6 problems. Failed to solve crack-the-safe because I had some mistakes in my formulas, and also because I could not make Cado run on my pc ü§°. Anyways, here are the writeups of the challenges I solved. ","date":"2023-07-03","objectID":"/uiu-crypto/:1:0","tags":["crypto","UIU CTF","english"],"title":"UIU CTF 2023 - Cryptography Writeups","uri":"/uiu-crypto/"},{"categories":["Writeups"],"content":"Three-Time Pad Challenge Information\rPoints: 50 Description: ‚ÄúWe‚Äôve been monitoring our adversaries‚Äô communication channels, but they encrypt their data with XOR one-time pads! However, we hear rumors that they‚Äôre reusing the pads‚Ä¶ Enclosed are three encrypted messages. Our mole overheard the plaintext of message 2. Given this information, can you break the enemy‚Äôs encryption and get the plaintext of the other messages?‚Äù Artifacts are c1, c2, c3, p2.\rSimple XOR challenge. We are given 3 encrypted files c1, c2, c3 all encrypted with the same key K. The original second file p2 has been given too. So it‚Äôs trivial to retrieve the key now. K = p2 ^ c2 p1 = K ^ c1 p3 = K ^ c3 Then we check which of p1 or p3 contains the flag and we see that p3 indeed has the flag. from pwn import * with open('c1' ,'rb') as f: c1 = f.read() with open('c2' ,'rb') as f: c2 = f.read() with open('c3' ,'rb') as f: c3 = f.read() with open('p2' ,'rb') as f: p2 = f.read() key = xor(c2, p2) m1 = xor(c1, key) m2 = xor(c3, key) print(m1) print(m2) Flag: uiuctf{burn_3ach_k3y_aft3r_us1ng_1t} ","date":"2023-07-03","objectID":"/uiu-crypto/:2:0","tags":["crypto","UIU CTF","english"],"title":"UIU CTF 2023 - Cryptography Writeups","uri":"/uiu-crypto/"},{"categories":["Writeups"],"content":"At Home Challenge Information\rPoints: 50 Description: Mom said we had food at home Artifacts are chal.py and chal.txt\rFrom the source code, it can be seen that, $$c = flag*e\\mod\\ n$$ We can just re-write the equation as, $$flag = c*e^{-1}\\mod\\ n $$ Since we are given all the parameters, c, e, n, it‚Äôs trivial to retrieve the flag. from Crypto.Util.number import long_to_bytes as l2b flag = (c * pow(e, -1, n)) % n flag = l2b(flag) Flag: uiuctf{W3_hav3_R5A_@_h0m3} ","date":"2023-07-03","objectID":"/uiu-crypto/:3:0","tags":["crypto","UIU CTF","english"],"title":"UIU CTF 2023 - Cryptography Writeups","uri":"/uiu-crypto/"},{"categories":["Writeups"],"content":"Group project Challenge Information\rPoints: 50 Description: In any good project, you split the work into smaller tasks‚Ä¶ nc group.chal.uiuc.tf 1337 Artifacts are chal.py Let‚Äôs have a look at the source code, we are given a classic implementation of diffie hellman cryptosystem. def main(): print(\"[$] Did no one ever tell you to mind your own business??\") g, p = 2, getPrime(1024) a = randint(2, p - 1) A = pow(g, a, p) print(\"[$] Public:\") print(f\"[$] {g = }\") print(f\"[$] {p = }\") print(f\"[$] {A = }\") try: k = int(input(\"[$] Choose k = \")) except: print(\"[$] I said a number...\") if k == 1 or k == p - 1 or k == (p - 1) // 2: print(\"[$] I'm not that dumb...\") Ak = pow(A, k, p) b = randint(2, p - 1) B = pow(g, b, p) Bk = pow(B, k, p) S = pow(Bk, a, p) key = hashlib.md5(long_to_bytes(S)).digest() cipher = AES.new(key, AES.MODE_ECB) c = int.from_bytes(cipher.encrypt(pad(flag, 16)), \"big\") print(\"[$] Ciphertext using shared 'secret' ;)\") print(f\"[$] {c = }\") We have to provide such a value of k, for which we know the value of S. What happens if k = 0 ? Let‚Äôs see the math $$ \\begin{aligned} Bk \u0026 \\equiv B ^ 0 \u0026 \\equiv 1 \u0026 \\mod p \\\\ S \u0026 \\equiv 1 ^ a \u0026 \\equiv 1 \u0026 \\mod p \\end{aligned} $$ So we now know S. From here on it‚Äôs trivial to recover the key and hence get the flag. from Crypto.Util.number import getPrime, long_to_bytes from random import randint import hashlib from Crypto.Cipher import AES from Crypto.Util.Padding import pad from pwn import * io = remote('group.chal.uiuc.tf', 1337) key = hashlib.md5(long_to_bytes(1)).digest() cipher = AES.new(key, AES.MODE_ECB) io.recvuntil(b'??') io.recvline() io.recvline() g = int(io.recvline().decode().strip().split('=')[1]) p = int(io.recvline().decode().strip().split('=')[1]) A = int(io.recvline().decode().strip().split('=')[1]) io.recvuntil(b'= ') io.sendline(b'0') io.recvuntil(b'= ') enc = int(io.recvline().decode().strip()) flag = cipher.decrypt(long_to_bytes(enc)) print(flag) Flag: uiuctf{brut3f0rc3_a1n‚Äôt_s0_b4d_aft3r_all!!11!!} ","date":"2023-07-03","objectID":"/uiu-crypto/:4:0","tags":["crypto","UIU CTF","english"],"title":"UIU CTF 2023 - Cryptography Writeups","uri":"/uiu-crypto/"},{"categories":["Writeups"],"content":"Group projection Challenge Information\rPoints: 50 Description: I gave you an easier project last time. This one is sure to break your grade! nc group-projection.chal.uiuc.tf 1337 Artifacts are chal.py Almost the same problem as before, but with some extra constraints. if k == 1 or k == p - 1 or k == (p - 1) // 2 or k \u003c= 0 or k \u003e= p: print(\"[$] I'm not that dumb...\") return We can‚Äôt set k = 0 anymore. What can we do then? Is there a way to force S to be 1 like before? Since p is a prime, we could have set k = p - 1 and S would have been 1, due to Fermat‚Äôs little theorem. $$ \\begin{aligned} Bk \u0026 \\equiv B^{p-1} \u0026 \\equiv 1 \\mod p \\\\ S \u0026 \\equiv 1 ^ a \u0026 \\equiv 1 \\mod p \\end{aligned} $$ But we can‚Äôt set k = p - 1 due to constraints, sadly. What if we send k = (p - 1) / 4 instead? Now, when such a case comes so that $p - 1 \\mod\\ 4 \\equiv\\ 0$ and also $a*b \\mod\\ 4 \\equiv\\ 0$, what happens? Since a*b is a multiple of 4, we can write it as $a * b = 4*i$ for some integer i. $$ \\begin{aligned} S \u0026 \\equiv\\ g^{a * b * k} \u0026 \\mod p \\\\ S \u0026 \\equiv\\ g^{4i * \\frac{p-1}{4}} \u0026 \\mod p \\\\ S \u0026 \\equiv\\ ({g^{p-1}})^i \u0026 \\mod p \\\\ S \u0026 \\equiv\\ 1^i \\equiv\\ 1 \u0026 \\mod p \\end{aligned} $$ Yep, the math adds up and we have S = 1. We keep running the instance until the required conditions are fulfilled, and once we get such an instance, we can decrypt the flag. from Crypto.Util.number import getPrime, long_to_bytes from random import randint import hashlib from Crypto.Cipher import AES from Crypto.Util.Padding import pad from pwn import * def attempt(): io = remote('group-projection.chal.uiuc.tf', 1337) key = hashlib.md5(long_to_bytes(1)).digest() cipher = AES.new(key, AES.MODE_ECB) io.recvuntil(b'??') io.recvline() io.recvline() g = int(io.recvline().decode().strip().split('=')[1]) p = int(io.recvline().decode().strip().split('=')[1]) A = int(io.recvline().decode().strip().split('=')[1]) if (p - 1) % 4 != 0: return True print('Maybe???') k = (p - 1) // 4 io.recvuntil(b'= ') io.sendline(str(k).encode()) io.recvuntil(b'= ') enc = int(io.recvline().decode().strip()) flag = cipher.decrypt(long_to_bytes(enc)) if b\"uiuctf\" in flag: print(flag) return False else: print('Oh no!!') return True while attempt(): continue After running around a minute or so, we get the flag. Flag: uiuctf{brut3f0rc3_w0rk3d_b3f0r3_but_n0t_n0w!!11!!!} ","date":"2023-07-03","objectID":"/uiu-crypto/:5:0","tags":["crypto","UIU CTF","english"],"title":"UIU CTF 2023 - Cryptography Writeups","uri":"/uiu-crypto/"},{"categories":["Writeups"],"content":"Morphing Time Challenge Information\rPoints: 50 Description: The all revealing Oracle may be revealing a little too much‚Ä¶ nc morphing.chal.uiuc.tf 1337 Artifacts are chal.py Let‚Äôs go through the given script def setup(): # Get group prime + generator p = getPrime(512) g = 2 return g, p def key(g, p): # generate key info a = randint(2, p - 1) A = pow(g, a, p) return a, A def encrypt_setup(p, g, A): def encrypt(m): k = randint(2, p - 1) c1 = pow(g, k, p) c2 = pow(A, k, p) c2 = (m * c2) % p return c1, c2 return encrypt def decrypt_setup(a, p): def decrypt(c1, c2): m = pow(c1, a, p) m = pow(m, -1, p) m = (c2 * m) % p return m return decrypt def main(): print(\"[$] Welcome to Morphing Time\") g, p = 2, getPrime(512) a = randint(2, p - 1) A = pow(g, a, p) decrypt = decrypt_setup(a, p) encrypt = encrypt_setup(p, g, A) print(\"[$] Public:\") print(f\"[$] {g = }\") print(f\"[$] {p = }\") print(f\"[$] {A = }\") c1, c2 = encrypt(flag) print(\"[$] Eavesdropped Message:\") print(f\"[$] {c1 = }\") print(f\"[$] {c2 = }\") print(\"[$] Give A Ciphertext (c1_, c2_) to the Oracle:\") try: c1_ = input(\"[$] c1_ = \") c1_ = int(c1_) assert 1 \u003c c1_ \u003c p - 1 c2_ = input(\"[$] c2_ = \") c2_ = int(c2_) assert 1 \u003c c2_ \u003c p - 1 except: print(\"!! You've Lost Your Chance !!\") exit(1) print(\"[$] Decryption of You-Know-What:\") m = decrypt((c1 * c1_) % p, (c2 * c2_) % p) print(f\"[$] {m = }\") # !! NOTE !! # Convert your final result to plaintext using # long_to_bytes exit(0) This is the Elgamal Cryptosystem, which is homomorphic under multiplication. We have, $$ \\begin{align} c_1 \u0026 = g^k \u0026 \\mod p \\\\ c_2 \u0026 = g^{ak} * m \u0026 \\mod p \\end{align} $$ To take advantage of the homomorphic property, we send c1_ = c1 and c2_ = c2. So now we have, $$ \\begin{aligned} c_1 \u0026 = g^{2k} \u0026 \\mod p \\\\ c_2 \u0026 = g^{2ak} * m^2 \u0026 \\mod p \\end{aligned} $$ And they decrypt to, $$({c_1 ^ a}) ^ {-1} * c_2 \\equiv\\ g^{-2ak} * g^{2ak} * m^2 \\equiv\\ m^2 \\mod p$$ This gives us the flag squared modulo p. To retrieve the flag, we can use tonelli shanks algorithm. But the problem is, the result does not decrypt to a valid string. This made me think that maybe flag \u003e p, and that‚Äôs why we are losing information. As a fix, we can run the instance multiple times, collect the square root and modulus pairs and run CRT on each of those pairs to see which gives us the flag. from Crypto.Util.number import long_to_bytes from sympy.ntheory.modular import crt from pwn import * def legendre(a, p): return pow(a, (p - 1) // 2, p) def tonelli(n, p): assert legendre(n, p) == 1, \"not a square (mod p)\" q = p - 1 s = 0 while q % 2 == 0: q //= 2 s += 1 if s == 1: return pow(n, (p + 1) // 4, p) for z in range(2, p): if p - 1 == legendre(z, p): break c = pow(z, q, p) r = pow(n, (q + 1) // 2, p) t = pow(n, q, p) m = s t2 = 0 while (t - 1) % p != 0: t2 = (t * t) % p for i in range(1, m): if (t2 - 1) % p == 0: break t2 = (t2 * t2) % p b = pow(c, 1 \u003c\u003c (m - i - 1), p) r = (r * b) % p c = (b * b) % p t = (t * c) % p m = i return r def get_params(): io = remote('morphing.chal.uiuc.tf', 1337) io.recvuntil(b'Public:\\n') g = int(io.recvline().decode().strip().split('=')[1]) p = int(io.recvline().decode().strip().split('=')[1]) A = int(io.recvline().decode().strip().split('=')[1]) io.recvline() c1 = int(io.recvline().decode().strip().split('=')[1]) c2 = int(io.recvline().decode().strip().split('=')[1]) io.recvline() io.recvuntil(b'= ') io.sendline(str(c1).encode()) io.recvuntil(b'= ') io.sendline(str(c2).encode()) io.recvline() m = int(io.recvline().decode().strip().split('=')[1]) return p, m mods = [] vals = [] for i in range(10): p, m = get_params() res = tonelli(m, p) mods.append(p) vals.append(res) sz = len(mods) print('Will start doing the CRTS') for i in range(sz - 1): for j in range(i + 1, sz): ans = long_to_bytes(crt([mods[i], mods[j]], [vals[i], vals[j]])[0]) if b'uiuctf' in ans: print(ans) exit(2) Flag: uiuctf{h0m0m0rpi5sms_ar3_v3ry_fun!!11!!11!!} ","date":"2023-07-03","objectID":"/uiu-crypto/:6:0","tags":["crypto","UIU CTF","english"],"title":"UIU CTF 2023 - Cryptography Writeups","uri":"/uiu-crypto/"},{"categories":null,"content":"About Me","date":"0001-01-01","objectID":"/aboutme/","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":null,"content":"Some Background Information From KCSC ","date":"0001-01-01","objectID":"/aboutme/:1:0","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":null,"content":"Contact Me You can contact me via Email, or Github. ","date":"0001-01-01","objectID":"/aboutme/:2:0","tags":null,"title":"About Me","uri":"/aboutme/"}]